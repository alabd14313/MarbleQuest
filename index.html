<!DOCTYPE html><html><head><title>Marble Quest</title><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui=1"><meta charset="UTF-8"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="description" content=""><link rel="manifest" href="manifest.json"><link rel="icon" type="image/png" href="icon64.png"><link rel="apple-touch-icon" sizes="180x180" href="icon180.png"><link rel="icon" type="image/png" sizes="32x32" href="icon32.png"><link rel="icon" type="image/png" sizes="16x16" href="icon16.png"><style>html,body {
  margin: 0;
  padding: 0;
  background-color: #000;
  overflow:hidden;
  font-family: Verdana;
}
.noselect {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
#canvaswrapper {
  text-align: center ;
}
</style><style>@font-face { font-family: "BitCell" ; src: url("fonts/BitCell.ttf") format("truetype"); }</style><style>@font-face { font-family: "GenericMobileSystem" ; src: url("fonts/GenericMobileSystem.ttf") format("truetype"); }</style><style>@font-face { font-family: "MisterPixel" ; src: url("fonts/MisterPixel.ttf") format("truetype"); }</style><script>window.fonts = ["BitCell","GenericMobileSystem","MisterPixel"]</script></head><body class="noselect custom-cursor" oncontextmenu="return false;"><div id="canvaswrapper"></div><script type="text/javascript">var resources = {"images":[{"file":"arrowleft.png","version":6,"size":242,"properties":{"frames":1,"fps":5}},{"file":"arrowright.png","version":8,"size":248,"properties":{"frames":1,"fps":5}},{"file":"ball.png","version":101,"size":989,"properties":{"frames":6,"fps":10}},{"file":"ball_shadow.png","version":41,"size":424,"properties":{"frames":1,"fps":5}},{"file":"ballfire.png","version":61,"size":2926,"properties":{"frames":5,"fps":6}},{"file":"bluebox.png","version":122,"size":1892,"properties":{"frames":2,"fps":9}},{"file":"bluewater.png","version":60,"size":1349,"properties":{"frames":2,"fps":9}},{"file":"cloudbox1.png","version":1,"size":515,"properties":{"frames":1,"fps":5}},{"file":"cloudbox2.png","version":1,"size":527,"properties":{"frames":1,"fps":5}},{"file":"cloudflat.png","version":19,"size":303,"properties":{"frames":1,"fps":5}},{"file":"cloudrampdx.png","version":1,"size":514,"properties":{"frames":1,"fps":5}},{"file":"cloudrampsx.png","version":6,"size":314,"properties":{"frames":1,"fps":5}},{"file":"collectable_reverse.png","version":80,"size":381,"properties":{"frames":1,"fps":5}},{"file":"collectable_shadow.png","version":34,"size":154,"properties":{"frames":1,"fps":5}},{"file":"collectible_anhk.png","version":12,"size":963,"properties":{"frames":5,"fps":5}},{"file":"collectible_anhk_empty.png","version":19,"size":298,"properties":{"frames":1,"fps":5}},{"file":"collectible_goldenapple.png","version":153,"size":1102,"properties":{"frames":5,"fps":5}},{"file":"collectible_goldenapple_empty.png","version":19,"size":402,"properties":{"frames":1,"fps":5}},{"file":"collectible_ruby.png","version":19,"size":629,"properties":{"frames":5,"fps":5}},{"file":"collectible_ruby_empty.png","version":28,"size":310,"properties":{"frames":1,"fps":5}},{"file":"collectible_star.png","version":238,"size":879,"properties":{"frames":5,"fps":4}},{"file":"collectible_star_empty.png","version":15,"size":269,"properties":{"frames":1,"fps":5}},{"file":"doorblock.png","version":103,"size":592,"properties":{"frames":1,"fps":5}},{"file":"doorblockcenter.png","version":116,"size":2594,"properties":{"frames":6,"fps":4}},{"file":"doorwaydx.png","version":29,"size":3908,"properties":{"frames":1,"fps":5}},{"file":"doorwaydxhalf1.png","version":97,"size":413,"properties":{"frames":1,"fps":5}},{"file":"doorwaydxhalf2.png","version":41,"size":428,"properties":{"frames":1,"fps":5}},{"file":"doorwaysx.png","version":4,"size":3999,"properties":{"frames":1,"fps":5}},{"file":"doorwaysxhalf1.png","version":1,"size":2166,"properties":{"frames":1,"fps":5}},{"file":"doorwaysxhalf2.png","version":3,"size":1926,"properties":{"frames":1,"fps":5}},{"file":"dungeonbox.png","version":1,"size":3004,"properties":{"frames":1,"fps":5}},{"file":"dungeonbox2.png","version":16,"size":3040,"properties":{"frames":1,"fps":5}},{"file":"dungeonbox_burning.png","version":55,"size":880,"properties":{"frames":1,"fps":9}},{"file":"dungeonboxunder.png","version":31,"size":2325,"properties":{"frames":1,"fps":5}},{"file":"dungeonboxunder2.png","version":46,"size":2493,"properties":{"frames":1,"fps":5}},{"file":"dungeonrampdx.png","version":1,"size":1067,"properties":{"frames":1,"fps":5}},{"file":"dungeonrampsx.png","version":1,"size":905,"properties":{"frames":1,"fps":5}},{"file":"dust.png","version":4,"size":264,"properties":{"frames":1,"fps":5}},{"file":"greenbox1.png","version":4,"size":770,"properties":{"frames":1,"fps":5}},{"file":"greenbox2.png","version":56,"size":550,"properties":{"frames":1,"fps":5}},{"file":"greenbox3.png","version":1,"size":1162,"properties":{"frames":1,"fps":5}},{"file":"greenok.png","version":1,"size":271,"properties":{"frames":1,"fps":5}},{"file":"greenrampdx.png","version":1,"size":553,"properties":{"frames":1,"fps":5}},{"file":"greenrampsx.png","version":1,"size":536,"properties":{"frames":1,"fps":5}},{"file":"help_icon.png","version":8,"size":467,"properties":{"frames":1,"fps":5}},{"file":"icon.png","version":49,"size":904,"properties":{"frames":1,"fps":5}},{"file":"lavafallbox.png","version":172,"size":1948,"properties":{"frames":2,"fps":4}},{"file":"lavafallflow.png","version":31,"size":2102,"properties":{"frames":2,"fps":5}},{"file":"marblequesttitle.png","version":98,"size":5565,"properties":{"frames":1,"fps":2}},{"file":"microstudiologo.png","version":1,"size":14005,"properties":{"frames":1,"fps":5}},{"file":"orangebox.png","version":1,"size":729,"properties":{"frames":1,"fps":5}},{"file":"orangerampdx.png","version":1,"size":573,"properties":{"frames":1,"fps":5}},{"file":"orangerampsx.png","version":1,"size":572,"properties":{"frames":1,"fps":5}},{"file":"plate.png","version":1,"size":497,"properties":{"frames":1,"fps":5}},{"file":"poster.png","version":2,"size":55895,"properties":{"frames":1,"fps":5}},{"file":"questcomplete.png","version":1,"size":712,"properties":{"frames":1,"fps":5}},{"file":"questscroll2.png","version":1,"size":400,"properties":{"frames":1,"fps":5}},{"file":"questscrollcenter.png","version":12,"size":160,"properties":{"frames":1,"fps":5}},{"file":"questscrollleft.png","version":1,"size":269,"properties":{"frames":1,"fps":5}},{"file":"questscrollright.png","version":2,"size":309,"properties":{"frames":1,"fps":5}},{"file":"sand_under.png","version":119,"size":398,"properties":{"frames":1,"fps":5}},{"file":"sandbox.png","version":121,"size":424,"properties":{"frames":1,"fps":5}},{"file":"sandrampdx.png","version":1,"size":309,"properties":{"frames":1,"fps":5}},{"file":"sandrampsx.png","version":1,"size":301,"properties":{"frames":1,"fps":5}},{"file":"shootingstar.png","version":1,"size":4909,"properties":{"frames":3,"fps":12}},{"file":"sprite.png","version":1,"size":96,"properties":{"frames":1,"fps":5}},{"file":"sprite2.png","version":1,"size":189,"properties":{"frames":1,"fps":5}},{"file":"sprite3.png","version":2,"size":514,"properties":{"frames":1,"fps":5}},{"file":"sprite4.png","version":2,"size":524,"properties":{"frames":1,"fps":5}},{"file":"violetbox.png","version":1,"size":535,"properties":{"frames":1,"fps":5}}],"assets":[],"maps":{"map1":"{\"width\":16,\"height\":10,\"block_width\":64,\"block_height\":64,\"sprites\":[0,\"cloudbox1\"],\"data\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}"},"sounds":[{"file":"fall.wav","version":1,"size":118016,"properties":{}},{"file":"jump.wav","version":1,"size":7590,"properties":{}},{"file":"stomp.wav","version":1,"size":4490,"properties":{}}],"music":[{"file":"daizlzeroimpression.mp3","version":1,"size":1625350,"properties":{}},{"file":"rolemusicstrawfields.mp3","version":1,"size":3602457,"properties":{}},{"file":"rolemusictheblackframe.mp3","version":1,"size":3731470,"properties":{}}]};
var graphics = "M1";

</script><script type="text/javascript">var orientation = 'portrait' ;
var aspect = '>16x9' ;
var ms_libs = [] ;
window.skip_service_worker = true;
window.exported_project = true;
</script><script type="text/javascript">//
          //
          // The game is started with the code below.
          // Once you have received the "started" signal (see below),
          // you can do the following:
          // 1) Inject functions or objects into the global context of the microStudio engine, example:
          //
          //   window.player.setGlobal("special_callback",function(x) { console.info(x) }) ;
          //   // Your microScript code can now call the "special_callback" function
          //
          // 2) Call microScript global functions from your JavaScript code, example:
          //
          //   window.player.call("call_me_from_javascript",[10,1000]) ;
          //   // arguments to the function call are provided as an array
          //
          // 3) Run a microScript code snippet from your JavaScript code, example:
          //
          //   window.player.exec("player.position_x = 50",function(result) { console.log(result) ; }) ;
          //

          window.addEventListener("load",function() {
            window.player = new Player(function(event) {
              if (event.name == "started") {
                // signal that the game is started
              }
              else if (event.name == "log") {
                // console.info(event.data) ;
              }
            }) ;
            document.body.focus() ;
          }) ;




</script><script src="parser.js"></script><script src="program.js"></script><script src="token.js"></script><script src="tokenizer.js"></script><script src="jstranspiler.js"></script><script src="runner_v1_t.js"></script><script src="microengine.js"></script></body><script id="code" type="text/x-microscript">

background = object

  topColor = "rgb(15,0,150)"
  headColor = "rgb(15,0,150)"
  bottomColor ="rgb(0,0,0)"

  init = function()
     pClouds = []
     for i=0 to 25
      local p = object
        x = 250-random.nextInt(500)
        y = 250-random.nextInt(500)
      end
      pClouds.push(p)
     end
     //--
     pStars = []
     for i=0 to 5
      local p = object
        x = 2500-random.nextInt(5000)
        y = 2500-random.nextInt(5000)
        angle = 10-random.nextInt(5)
        speed = 5+random.nextInt(25)
        scale = (20-random.nextInt(15))/10.0
      end
      pStars.push(p)
     end
  end
  
  drawShootingStar = function(s)
    screen.setDrawScale(s.scale,s.scale)
    screen.setDrawRotation(-s.angle)
    screen.drawSprite("shootingstar",s.x,s.y,86)
    screen.setDrawRotation(0)
    screen.setDrawScale(1,1)
  end
  
  update = function()
     for p in pClouds
        p.x -= player.speed.x/5.0 +0.1
        p.y -= player.speed.y/5.0  +0.1
        if abs(p.x) > 250 then p.x*=-1 end
        if abs(p.y) > 250 then p.y*=-1 end
     end
     
    for s in pStars
        s.x -= s.speed*sind(s.angle-45)
        s.y -= s.speed*cosd(s.angle-45)
        if abs(s.x) > 2500 then s.x*=-1 end
        if abs(s.y) > 2500 then s.y*=-1 end
    end
     
     if(system.time()-t > 250)then
      l += 0.01
      bottomColor = tools.toRGB(0.5,0.5,abs(sin(l)))
      
      if min(head1.distanceToPlayer,head2.distanceToPlayer) < 500 then
        if head1.distanceToPlayer < head2.distanceToPlayer then
          headColor = head1.biome.color1 
        else
          headColor = head2.biome.color1 
        end
      end
      
      rgbFrom = tools.colorToValues(topColor)
      hslFrom = tools.toHSL(rgbFrom[0],rgbFrom[1],rgbFrom[2])
      
      rgbHead = tools.colorToValues(headColor)
      hslHead = tools.toHSL(rgbHead[0],rgbHead[1],rgbHead[2])
      
      h1 = hslFrom[0] + (hslHead[0] - hslFrom[0]) / 50.0
      s1 = hslFrom[1] + (hslHead[1] - hslFrom[1]) / 50.0
      l1 = hslFrom[2] + (hslHead[2] - hslFrom[2]) / 50.0
      
      topColor = tools.toRGB(h1,s1,l1)
      
      t = system.time()
     end
  end

  draw = function()
    screen.setLinearGradient(100,-200,-100,200,bottomColor,topColor)
    screen.fillRect(0,0,screen.width,screen.height)
    
    for s in pStars
     drawShootingStar(s)
    end
    for p in pClouds
      screen.drawSprite("cloudflat",p.x,p.y,TILE_SIZE,TILE_SIZE)
    end
  end

end


biomes = []

biomeGreen = new object
  name = "green"
  ramp_sx = "greenrampsx"
  ramp_dx = "greenrampdx"
  solid_tiles =  ["greenbox1","greenbox2","greenbox3"]
  under_tiles = ["orangebox"]
  falling_tiles = ["bluebox","bluewater"]
  killer_tiles = []
  collectables = ["collectible_goldenapple"]
  color1 = "rgb(15,0,150)"
end
biomes.push(biomeGreen)

biomeSand = new object
  name = "sand"
  ramp_sx = "sandrampsx"
  ramp_dx = "sandrampdx"
  solid_tiles =  ["sandbox"]
  under_tiles = ["sand_under"]
  falling_tiles = []
  killer_tiles = []
  collectables = ["collectible_anhk"]
  color1 ="rgb(198,198,0)"
end
biomes.push(biomeSand)

biomeDungeon= new object
  name = "dungeon"
  ramp_sx = "dungeonrampsx"
  ramp_dx = "dungeonrampdx"
  solid_tiles =  ["dungeonbox","dungeonbox2"]
  under_tiles = ["dungeonboxunder","dungeonboxunder2","dungeonboxunder","dungeonboxunder"]
  falling_tiles = ["lavafallbox","lavafallflow"]
  killer_tiles = ["dungeonbox_burning"]
  collectables = ["collectible_ruby"]
  color1 ="rgb(45,45,45)"
end
biomes.push(biomeDungeon)

biomeCloud= new object
  name = "cloud"
  ramp_sx = "cloudrampsx"
  ramp_dx = "cloudrampdx"
  solid_tiles =  ["cloudbox1","cloudbox2"]
  under_tiles = ["cloudbox2"]
  falling_tiles = []
  killer_tiles = []
  collectables = ["collectible_star"]
  color1 ="rgb(210,210,210)"
end
biomes.push(biomeCloud)
  




block = class
  
  constructor = function(sprite,x,y,z,solid,locked,collectable)
    alive = true
    this.sprite = sprite
    this.w = sprites[sprite].width * TILE_SIZE / 64
    this.h = sprites[sprite].height * TILE_SIZE / 64
    this.pos = new p3d(x,y,z)
    this.speed = new p3d()
    this.acc = new p3d()
    this.solid = solid
    this.locked = locked
    this.collectable = collectable
    this.killer = false
    this.biome = 0
    this.emitter = 0
    
    isoX = 0
    isoY = 0
    sum = 0
    updateSum()
    updateISO()
  end
  
  updateISO = function()
    isoX = (pos.x-pos.y)/2 
    isoY = -(pos.x+pos.y)/4 + (pos.z/2) 
  end
  
  updateSum = function()
    sum = pos.x+pos.y+pos.z
  end
  
  update = function()
    if not locked then
      pos.x += speed.x
      pos.y += speed.y
      pos.z += speed.z

      updateSum()
      updateISO()
      
      speed.x += acc.x
      speed.y += acc.y
      speed.z += acc.z
    end
    
    if emitter and random.next()>0.90 then
      local e = new block(emitter,pos.x,pos.y,pos.z-h)
      e.acc.z = -0.2
      e.locked = false
      e.updateSum()
      e.updateISO()
      blocks.push(e)
    end
  end

  draw = function()
    screen.setDrawAnchor(0,-1)
    screen.drawSprite(sprite,isoX + camera.x,isoY + camera.y,w,h)
    screen.setDrawAnchor(0,0)
  end

end

button = class
  constructor = function(pX,pY,pWidth,pHeight,pSprite,pEvent=0)
    this.event = pEvent
    
    this.x = pX
    this.y = pY
    this.width = pWidth //sprites[pSprite].width + 10
    this.height = pHeight //sprites[pSprite].height + 10
    this.sprite = pSprite
    this.flipV = false
    
    this.colorBackgroundHover ="rgb(255,255,255)"
    this.colorBackground ="rgb(75,75,75)"
    
    // bool
    this.isHover = 0
    this.isPressed = 0
  end
  
  update = function()
    
    //Check is mouse Hover
    local mX = mouse.x
    local mY = mouse.y
    
    if mX> (x-width/2) and mX<(x+width/2) and
       mY> (y-height/2) and mY<(y+height/2) then
      isHover = 1
    else
      isHover = 0
    end
    
    // Check if mouse is pressed
    if isHover and mouse.pressed then
      if isPressed==0 then
        isPressed = 1
        if event then 
        local e = event
          e()
        end
      end
    else
      isPressed = 0
    end
  end
  
  draw = function()
    // if button is hover change Background color
    local color = colorBackground
    if isHover then
      color = colorBackgroundHover
    end
  
    screen.setAlpha(0.5)
    screen.fillRoundRect(x,y,width,height,15,color)
    if flipV then screen.setDrawScale(1,-1) end
    screen.drawSprite(sprite,x,y,sprites[sprite].width)
    screen.setDrawScale(1,1)
    screen.setAlpha(1)
  end
  
end


camera = object
  x = 0
  y = 0
  xt = 0
  yt = 0
  
  moveTo = function(x,y)
    xt = x
    yt = y
  end
  
  update = function()
    x += (xt-x)/30.0
    y += (yt-y)/30.0
  end
end

// Functions based on the code from https://easings.net/

EaseType = object
  linear = function(x)
    return x
  end

  easeInSine = function(x)
    return 1 - cos((x * PI) / 2)
  end

  easeOutSine = function(x)
    return sin((x * PI) / 2)
  end
  
  easeInOutSine = function(x)
    return -(cos(PI * x) - 1) / 2
  end
  
  easeInQuad = function(x)
    return x^2
  end
  
  easeOutQuad = function(x)
    return 1 - (1 - x)^2
  end
  
  easeInOutQuad = function(x)
    return if x < 0.5 then 2 * x^2 else 1 - (-2 * x + 2)^2 / 2 end
  end

  easeInCubic = function(x)
    return x^3
  end
  
  easeOutCubic = function(x)
    return 1 - (1 - x)^3
  end
  
  easeInOutCubic = function(x)
    return if x < 0.5 then 4 * x^3 else 1 - (-2 * x + 2)^3 / 2 end
  end
  
  easeInQuart = function(x)
    return x^4
  end
  
  easeOutQuart = function(x)
    return 1 - (1 - x)^4
  end
  
  easeInOutQuart = function(x)
    return if x < 0.5 then 8 * x^4 else 1 - (-2 * x + 2)^4 / 2 end
  end
  
  easeInQuint = function(x)
    return x^5
  end
  
  easeOutQuint = function(x)
    return 1 - (1 - x)^5
  end
  
  easeInOutQuint = function(x)
    return if x < 0.5 then 16 * x^5 else 1 - (-2 * x + 2)^5 / 2 end
  end
  
  easeInExpo = function(x)
    return if x == 0 then 0 else pow(2, 10 * x - 10) end
  end
  
  easeOutExpo = function(x)
    return if x == 1 then 1 else 1- pow(2, -10 * x) end
  end
  
  easeInOutExpo = function(x)
    return if x == 0 then 0
      elsif x == 1 then 1
      elsif x < 0.5 then pow(2, 20 * x - 10) / 2
      else (2 - pow(2, -20 * x + 10)) / 2 end
  end
  
  easeInCirc = function(x)
    return 1 - sqrt(1 - pow(x, 2))
  end
  
  easeOutCirc = function(x)
    return sqrt(1 - pow(x - 1, 2))
  end
  
  easeInOutCirc = function(x)
    return if x < 0.5 then (1 - sqrt(1 - pow(2 * x, 2))) / 2
      else(sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2 end
  end
  
  easeInBack = function(x)
    local c1 = 1.70158
    local c3 = c1 + 1

    return c3 * x^3 - c1 * x^2 
  end
  
  easeOutBack = function(x)
    local c1 = 1.70158
    local c3 = c1 + 1

    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2)
  end
  
  easeInOutBack = function(x)
    local c1 = 1.70158
    local c2 = c1 * 1.525

    return if x < 0.5 then (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
      else (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2 end
  end

  
  easeInElastic = function(x)
    local c4 = (2 * PI) / 3
    return if x == 0 then 0
      elsif x == 1 then 1
      else -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4) end
  end

  easeOutElastic = function(x)
    local c4 = (2 * PI) / 3
    return if x == 0 then 0
      elsif x == 1 then 1
      else pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1 end
  end

  
  easeInOutElastic = function(x)
    local c5 = (2 * PI) / 4.5
    return if x == 0 then 0
      elsif x == 1 then 1
        elsif x < 0.5 then -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2
      else (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1 end
  end

  easeInBounce = function(x)
    return 1 - easeOutBounce(1 - x)
  end

  easeOutBounce = function(x)
    local n1 = 7.5625
    local d1 = 2.75
    
    if x < 1 / d1 then
      return n1 * x * x
    elsif x < 2 / d1 then
      return n1 * (x -= 1.5 / d1) * x + 0.75
    elsif x < 2.5 / d1 then
      return n1 * (x -= 2.25 / d1) * x + 0.9375
    else
      return n1 * (x -= 2.625 / d1) * x + 0.984375
    end    
  end
  
  easeInOutBounce = function(x)
    return if x < 0.5 then (1 - easeOutBounce(1 - 2 * x)) / 2
    else (1 + easeOutBounce(2 * x - 1)) / 2 end
  end

end

 fps = object
   count = 0
   tt = system.time()
   update = function()
     if count >=60 then
        local t = system.time()-tt
        fps = round(count/(t/1000))
        tt = system.time()
        count = 0
      end
      count += 1
  end
  
end


gui = object

  plotData = []
  
  init = function()
    btn_left = new button(-80,-175 + 30,60,40,"arrowleft",0)
    btn_right = new button(80,-175 + 30,60,40,"arrowright",0)
    btn_reverse = new button(0,-175 + 30,60,40,"collectable_reverse",reverse_player)
    btn_help = new button(85,160,25,25,"help_icon",show_help)
    show_btns = true
    touch_counts = 0
    ms_last_input = system.time()
  end
  
  update = function()
    btn_left.flipV = levelReverse
    btn_right.flipV = levelReverse
    
    btn_left.update()
    btn_right.update()
    btn_reverse.update()
    btn_help.update()
    
    if touch.press then
      show_btns = false
      touch_counts += 1
      ms_last_input = system.time()
    end
    if keyboard.LEFT or keyboard.RIGHT then
      show_btns = false
      touch_counts += 1
      ms_last_input = system.time()
    end
    //Show controls also if user have learn to use it
    local ms_from_last = system.time() - ms_last_input
    if ms_from_last > 10000 then 
      show_btns = true
    end
  end

  draw = function()
    if quests.showScroll then
      if show_btns then
        btn_left.draw()
        btn_right.draw()
      end
      if global.reverseCount>0 then
          btn_reverse.draw()
      end
      screen.drawText("SCORE: "+score,0,165,12,"rgb(255,255,255)")
      screen.drawText("HIGH: "+highScore,0,150,12,"rgb(255,255,255)")
    else
      btn_help.draw()
    end
    
    //debug
    // screen.setDrawAnchor(-1,0)
    // screen.drawText("fps: "+fps.fps,-90,170,8,"rgb(255,255,255)")
    // screen.drawText("#: "+blocks.length,-90,160,8,"rgb(255,255,255)")
    // screen.drawText("peak: "+round(update_time)+"ms",-90,150,8,"rgb(255,255,255)")
    // screen.drawText("speed: "+round(levelSpeed),-90,140,8,"rgb(255,255,255)")
    // screen.setDrawAnchor(0,0)
    //------------------------
    // screen.drawLine(-100,150,100,150,"#FFF")
    // screen.drawLine(-100,150+16,100,150+16,"#FFF")
    // x = -100
    // for p in plotData 
    //   screen.fillRect(x,150+p,1,1,"rgb(255,0,85)")
    //   x+=1
    // end
    
  end

end


help = object

  init = function()
    enable = false
    state_time = 0
    states_text = [
      "شما می توانید با لمس چپ یا راست صفحه|جهت خود را تغییر دهید",
      "دو بار لمس کردن در جهت یکسان |باعث پرش می شود",
      "آیتم ها را جمع کن|تا از سرعت بازی بکاهی"
      ]
    state_intro = false
  end

  nextState = function()
    state += 1
    state_time = 0
    global.pauseTutorial = true
  end
  
  anyKey = function()
    return mouse.press or keyboard.press.LEFT or keyboard.press.RIGHT
  end

  update = function()
    if enable then
      state_time+=0.016
      
      if state_time>5 or anyKey() then
        nextState()
      end
      
      if state>=help.states_text.length then
        enable = false
      end
     
    end
    
  end
  
  
  draw = function()
    if enable then
      local x = 0
     
      scrollHeight = 24+states_text[state].split("|").length * 12
      
      screen.drawSprite("questscroll2",0,0,190,scrollHeight)
      
      local y = (scrollHeight-36)/2
      for line in states_text[state].split("|")
        screen.drawText(line,x,y,10,"rgb(0,0,0)")
        y -= 12
      end
    end
    
  end


end

intro = object
  
  init = function()
    ss = 1
    yIntro = 0
    yBallIntro = 340
    stomped = false
  end
  
  modulo = function(x,y)
    x-y*floor(x/y)
  end

  update = function()
    
    if pauseIntro then
      t += 0.0025
      t=t%2
      rot1 = EaseType.easeInOutElastic(t)*PI
      rot2 = EaseType.easeInOutElastic(t-1)*PI
      rot = rot1 + rot2
    end
    
    if not pauseIntro and yBallIntro > 0 then
      yBallIntro -= 10
      ss = (400/abs(camera.y))
      yIntro = camera.y+400
    end
    
    if not stomped and yBallIntro<=0 then
        stomped = true
        sounds.stomp()
    end
  end

  draw = function()
    if(yBallIntro>0) then
      screen.drawSprite("marblequesttitle",player.pos.x,yIntro,256/ss)
      screen.setDrawAnchor(0,-1)
      screen.drawSprite("ball",
        player.isoX + camera.x,
        player.isoY + camera.y + yBallIntro,
        TILE_SIZE*4/ss)
      screen.setDrawAnchor(0,0)
    end
    
     if not quests.showScroll and screen.isFontReady(FONT) then
      local xn = 50 * sin(rot)
      local yn = 10 * cos(rot)
      screen.drawText("Created by Hamidreza",xn,145+yn,16,"rgb(255,255,255)")
      local xn = 50 * sin(rot+PI)
      local yn = 10 * cos(rot+PI)
      screen.drawText("For Kiana",xn,145+yn,16,"#FFF")
    end
    
  end

end

lights = object

  radius = 50
  f = 0
  
  update = function()
    f += 0.05
    radius = 80 + 10*sin(f)
  end

  draw = function()
    screen.setRadialGradient( player.isoX+ camera.x,player.isoY+ camera.y,radius,
    "rgb(0,0,0,0)",  "rgb(0,0,0,1)")
    screen.fillRect(0,0,screen.width,screen.height)
    screen.setColor("rgb(0,0,0,0)")
  end

end

TILE_SIZE = 24
TARGET_BLOCKS_COUNT = 130 //130
MIN_DISTANCE_FOR_MORE_PATH = 200 //200
MAX_DISTANCE_FOR_DEACTIVATE_HEAD = 500//500
GRAVITY = 0.5
PAUSE = false
FONT = "GenericMobileSystem" //"MisterPixel"
TUTORIAL_MODE = true

//TODO: test variable FPS for animation
// sprites[player].fps = xx

init = function()
  screen.loadFont(FONT)
  songs.fadeToNextSong(0)
  highScore = storage.get("highScore")
  if(score > highScore) then
    storage.set("highScore",score)
    highScore = score
  end
  
  ms_last = 0
  levelSpeed = 1
  levelReverse = 0
  score = 0
  biome_changes = 0
  pauseIntro = true
  pauseGame = false
  rotAngle = 0
  reverseCount = 0
  
  local headActive = random.next()>0.5
  head1 = new pathhead(1,headActive,biomes[0])
  head2 = new pathhead(-1,not headActive,biomes[0])
  
  intro.init()
  help.init()
  background.init()
  gui.init()
  quests.init()
  particles.init()
  
  blocks = []
  blocksRot = []
  addStartBlocks()
  initPlayer()
  
  camera.x = 0
  camera.y = -400
end

initPlayer = function()
  player = new playerblock("ball",0,0,5*TILE_SIZE,true,false)
  blocks.push(player)
end

zsort = function(b1,b2)
  return b1.sum-b2.sum
end

addStartBlocks = function()
  for x = -2 to 2
    for y = -2 to 2
      local b = new block("greenbox1",x*TILE_SIZE,y*TILE_SIZE,-TILE_SIZE,true,true)
      blocks.push(b)
    end
  end
  for x = -1 to 1
    for y = -1 to 1
      local b = new block("greenbox1",x*TILE_SIZE,y*TILE_SIZE,0,true,true)
      blocks.push(b)
    end
  end
  blocks.push(b)
  
  if head1.active then
   addDoor(head1.pos.x,head1.pos.y,head1.pos.z+TILE_SIZE,head1.dir,true)
  end
  if head2.active then
   addDoor(head2.pos.x,head2.pos.y,head2.pos.z+TILE_SIZE,head2.dir,true)
  end
end


addMorePath = function(head)
  //-------
  head.steps += 1
  head.steps_total += 1
  head.stepsFromChanges +=1
  //change direction randomly
  local changeDir = (random.nextInt(100)>70 and head.steps>1 and head.stepsFromChanges>2)
  if changeDir then
    head.steps = 0
    head.stepsFromChanges = 0
    head.dir = head.dir * -1 //change pathDir
    if levelReverse then
      head.pos.z -= TILE_SIZE //step down
    else
      head.pos.z += TILE_SIZE //step up    
    end
  end
  
  //step ahead in direction
  head.stepAhead()
  
  //path name
  local bName = tools.randomList(head.biome.solid_tiles)
  local falling = false
  local killer = false
  if head.biome.falling_tiles.length>0 then
    if random.next()>0.9 and head.stepsFromChanges>2 then 
      bName = head.biome.falling_tiles[0]
      head.stepsFromChanges=0
      falling = true
    end
  end
  if head.biome.killer_tiles.length>0 then
    if random.next()>0.9 and head.stepsFromChanges>2 then 
      bName = tools.randomList(head.biome.killer_tiles)
      head.stepsFromChanges=0
      killer = true
    end
  end
  if changeDir then
    if head.dir >0 then
      bName = head.biome.ramp_dx
    else
      bName = head.biome.ramp_sx
    end
    //Add ramp
    local rampZ = head.pos.z
    if levelReverse then rampZ += TILE_SIZE end
    local br = new block(bName,head.pos.x,head.pos.y,rampZ,true,true)
    br.acc.z = -0.025
    blocks.push(br)
  else
    //Add path block
    local ba = new block(bName,head.pos.x,head.pos.y,head.pos.z,true,true)
    ba.killer = killer
    if falling then  
      ba.emitter = head.biome.falling_tiles[1]
      ba.solid = false
    end
    ba.acc.z = -0.025
    ba.biome = head.biome.name
    blocks.push(ba)
  end
  
  //add under blocks 
  if not falling then
    local rnd = random.nextInt(100)
    local lz = 1 + random.nextInt(2)
    if rnd>40 then lz = 3+random.nextInt(3) end
    if rnd>80 then lz = 4+random.nextInt(4) end
    if head.biome == biomeSand then //sands is more regular
      lz = 1 + abs(head.steps%10-4)
    end
    
    for z = 1 to lz 
       local bNameUnder = tools.randomList(head.biome.under_tiles)
       local bf = new block(bNameUnder,head.pos.x,head.pos.y,head.pos.z- z*TILE_SIZE,false,true)
       bf.acc.x = (0.5-random.next())*0.05
       bf.acc.y = (0.5-random.next())*0.05
       bf.acc.z = -0.05*z
       //skip some to make holes (but not for sand biome)
       if (random.next()>0.1 or head.biome == biomeSand) then 
        blocks.push(bf)
       end
    end
  end
  
  //add collectables
  if head.steps>2 and random.next()>0.9 then
    local nameCollectable = tools.randomList(head.biome.collectables)
    if nameCollectable then
      local bc = new block(nameCollectable,head.pos.x,head.pos.y,head.pos.z+ 4*TILE_SIZE,false,true)
      bc.collectable = true
      bc.acc.z = -0.05
      blocks.push(bc)
      local bs = new block("collectable_shadow",head.pos.x,head.pos.y,head.pos.z,false,true)
      bs.acc.z = -0.05
      blocks.push(bs) //push shadow
      //---
      head.stepsFromChanges = 0 //reset changes
    end
  end
end

addDoor = function(dx,dy,dz,facing,fixed)
  local offx = 0
  local offy = 0
  if facing > 0 then 
     offx = 0
     offy = -TILE_SIZE
    else 
     offx = -TILE_SIZE
     offy = 0
  end

  for z = 0 to 2
    local sb1 = new block("doorblock",dx+offx,dy+offy,dz+(z*TILE_SIZE),false,true)
    if not fixed then sb1.acc.z = -0.1 end
    blocks.push(sb1)
    local sb2 = new block("doorblock",dx-offx,dy-offy,dz+(z*TILE_SIZE),false,true)
    if not fixed then sb2.acc.z = -0.1 end
    blocks.push(sb2)
  end
   local sbc = new block("doorblockcenter",dx,dy,dz+(2*TILE_SIZE),false,true)
   if not fixed then sbc.acc.z = -0.1 end
   blocks.push(sbc)
end

addFork = function()
  //Add fork platform
  local lastHead = 0
  if head1.distanceToPlayer <  head2.distanceToPlayer then
    lastHead = head1
  else 
    lastHead = head2
  end

  //platform fork
   for x=-2 to 2
     for y=-2 to 2
      if x!=0 or y!=0 then
        local bpx = lastHead.pos.x + x*TILE_SIZE
        local bpy = lastHead.pos.y + y*TILE_SIZE
        local bpz = lastHead.pos.z 
        local bType = tools.randomList(lastHead.biome.solid_tiles)
        local bp = new block(bType,bpx, bpy,bpz,true,true)
        bp.acc.z = -0.1
        blocks.push(bp)
      end
     end
   end
    
   //
   biome_changes += 1
   head1.active = true
   head2.active = true
   head1.biome = biomes[biome_changes%biomes.length] // tools.randomList(biomes)
   head2.biome = biomes[(biome_changes+1)%biomes.length] // tools.randomList(biomes)
   head1.stepsFromChanges = -random.nextInt(5)-1 //force direction
   head2.stepsFromChanges = -random.nextInt(5)-1 //force direction
   head1.steps_total = 0
   head2.steps_total = 0
   head1.dir = if head2.dir==1 then -1 else 1 end
   head2.dir = if head1.dir==1 then -1 else 1 end
     
   //step ahead in direction to go outside platform
   head1.stepAhead()
   head2.stepAhead()
   head1.stepAhead()
   head2.stepAhead()
   
   addDoor(head1.pos.x,head1.pos.y,head1.pos.z,head1.dir)
   addDoor(head2.pos.x,head2.pos.y,head2.pos.z,head2.dir)
end

reverse_player = function()
   if reverseCount > 0 then
     global.reverseCount=global.reverseCount-1
     global.levelReverse = not global.levelReverse
     levelSpeed = levelSpeed / 3
     head1.pos.x = player.pos.x
     head1.pos.y = player.pos.y
     head1.pos.z = player.pos.z - TILE_SIZE
     
     head2.pos.x = player.pos.x
     head2.pos.y = player.pos.y
     head2.pos.z = player.pos.z - TILE_SIZE
     
     player.direction=0 //stop player
     
     //add some special effect and remove blocks
     for b in blocks
       if b.pos.distance(player.pos)>2*TILE_SIZE then
         b.locked = false
         b.solid = false
         b.acc.z = 0.1+random.next()*0.5
         b.acc.x = 0.1-random.next()*0.2
         b.acc.y = 0.1-random.next()*0.2
       end
     end
   end
end

unlock_arena = function()
  quests.arenaUnlocked = true
  //TODO:
   head1.active = false
   head2.active = false
   //send all blocks away
   for b in blocks
     b.locked = false
     b.solid = false
     b.acc.z = 0.1+random.next()*0.5
     b.acc.x = 0.1-random.next()*0.2
     b.acc.y = 0.1-random.next()*0.2
   end
   
   //create arena
  for x = -3 to 3
    for y = -3 to 3
      local bpx = player.pos.x + x*TILE_SIZE
      local bpy = player.pos.y + y*TILE_SIZE
      local bpz = player.pos.z 
      local b = new block("greenbox1",bpx,bpy,bpz,true,true)
      blocks.push(b)
    end
  end
end

show_help = function()
  help.enable = true
end

update = function()
  
  // if keyboard.I then
  //   player.pos.x -= 1
  // elsif keyboard.K then
  //   player.pos.x += 1
  // elsif keyboard.J then
  //   player.pos.y += 1
  // elsif keyboard.L then
  //   player.pos.y -= 1
  // elsif keyboard.O then
  //   player.pos.z += 5
  // elsif keyboard.U then
  //   player.pos.z -= 5
  // elsif keyboard.press.P then
  //   PAUSE = not PAUSE
  // elsif keyboard.press.T then
  //   pauseGame = not pauseGame
  // end
  
  if keyboard.press.R then
    reverse_player()
  end
  
  // if keyboard.press.T then
  //   unlock_arena()
  // end
  
  if screen.isFontReady(FONT) then
    screen.setFont(FONT) 
  end
  
  if pauseGame then
    //Build rotated blocks if game in pause
    blocksRot = []
      for b in blocks
        local rb = new block(b.sprite,b.pos.x,b.pos.y,b.pos.z)
        if transitionType == "rotate" then
          local newPos = tools.rot3d(rb.pos,player.pos,0,0,quests.rotAngle)
          rb.pos.x = newPos.x
          rb.pos.y = newPos.y
          rb.pos.z = newPos.z
        elsif transitionType == "sinusoidal_x" then
          rb.pos.x += 25*sin(quests.rotAngle+(rb.pos.x+rb.pos.y)/150.0)
        elsif transitionType == "sinusoidal_y" then
          rb.pos.y += 25*sin(quests.rotAngle+(rb.pos.x+rb.pos.y)/150.0)
        elsif transitionType == "sinusoidal_z" then
          rb.pos.z += 25*sin(quests.rotAngle+(rb.pos.x+rb.pos.y)/150.0)
        elsif transitionType == "shake" then
          rb.pos.x += (random.next()-0.5)*quests.rotAngle*5
          rb.pos.y += (random.next()-0.5)*quests.rotAngle*5
          rb.pos.z += (random.next()-0.5)*quests.rotAngle*5
        end
        //---------------
        rb.updateSum()
        rb.updateISO()
        blocksRot.push(rb)
      end
      blocksRot.sortList(zsort)
    else
      transitions = ["sinusoidal_x","sinusoidal_y","sinusoidal_z","rotate","shake"]
      //transitionType = tools.randomList(transitions)
      transitionType = transitions[quests.itemsToCollectForCompleteQuest-1%transitions.length]
  end
  
  local time = system.time()

  //Unpause
  if (mouse.press or keyboard.press.LEFT or keyboard.press.RIGHT) then
    if pauseIntro then pauseIntro = false return end
  end
  quests.showScroll = not pauseIntro
  
  background.update()
  //Camera usually follow player position
  if not pauseIntro then
    camera.xt = -player.isoX
    if levelReverse then
      camera.yt = -player.isoY + 20
    else
      camera.yt = -player.isoY - 80
    end
    camera.update()
  end
  
  //push new block to the path?
  local ms = system.time()
  if(ms-ms_last > 100) then
    
    //Calc distance from player to heads
    head1.distanceToPlayer = head1.pos.distance(player.pos)
    head2.distanceToPlayer = head2.pos.distance(player.pos)
    
    // //Stop head if not the one selected by player
    // if player.biomeUnder==head1.biome and head1.active and head1.steps_total>10 and
    //   player.biomeUnder==head2.biome and head2.active and head2.steps_total>10 then
    //   if head1.biome.name == player.biomeUnder then head2.active=false end
    //   if head2.biome.name == player.biomeUnder then head1.active=false end
    // end
    //Stop head if not the one selected by player
    if player.biomeUnder==head1.biome.name and head1.steps_total>10 then
      head2.active = false
    elsif player.biomeUnder==head2.biome.name and head2.steps_total>10 then
      head1.active = false
    end
    
    //Teleport other head if too distant
    local needFork = false
    if (head2.distanceToPlayer>500 and head1.stepsFromChanges>2) then
       needFork = true
       head2.pos.x = head1.pos.x
       head2.pos.y = head1.pos.y
       head2.pos.z = head1.pos.z
    elsif (head1.distanceToPlayer>500 and head2.stepsFromChanges>2) then
       needFork = true
       head1.pos.x = head2.pos.x
       head1.pos.y = head2.pos.y
       head1.pos.z = head2.pos.z
    end
    
    //Manage forks
    if needFork then
       addFork()
      else
       local pathAdded = false
       if(head1.active and head1.distanceToPlayer < MIN_DISTANCE_FOR_MORE_PATH) then
         addMorePath(head1)
         pathAdded = true
       end
       if(head2.active and head2.distanceToPlayer < MIN_DISTANCE_FOR_MORE_PATH) then
         addMorePath(head2)
         pathAdded = true
       end
       if pathAdded then 
         levelSpeed += 1
       end
    end
    
    //save time
    ms_last = ms //
  end

  //-----------------------------------
  if not pauseGame and not help.enable then
    
    player.update()
    for b in blocks  //foreach block
      if b==player then continue end
      //Update all blocks
      b.update()
      
      //Unlock blocks when behind player
      if (b.locked and 
        ((b.pos.x +b.pos.y < player.pos.x+player.pos.y-TILE_SIZE) and levelReverse) or
        (b.pos.x +b.pos.y > player.pos.x+player.pos.y+TILE_SIZE) and not levelReverse) then
        //And rise score only if falling block is solid one (walkable path)
        if not pauseIntro and b.solid and not player.dead then
          score += 1
        end
        if not quests.arenaUnlocked then
          b.locked = false
          b.solid = false
        end
      end
      
      //Check if blocks is collectable
      if b.collectable and 
        (player.pos.x>b.pos.x-TILE_SIZE/2 and player.pos.x<b.pos.x+TILE_SIZE/2) and 
        (player.pos.y>b.pos.y-TILE_SIZE/2 and player.pos.y<b.pos.y+TILE_SIZE/2) and 
        (player.pos.z>b.pos.z-TILE_SIZE/2 and player.pos.z<b.pos.z+TILE_SIZE/2) then
        blocks.removeElement(b)
        sounds.collect()
        quests.newItemCollected(b,50) 
      end
      
      //Check if blocks is a killer
      if b.killer and 
        (player.pos.x>b.pos.x-TILE_SIZE/2 and player.pos.x<b.pos.x+TILE_SIZE/2) and 
        (player.pos.y>b.pos.y-TILE_SIZE/2 and player.pos.y<b.pos.y+TILE_SIZE/2) and 
        (player.pos.z>b.pos.z-TILE_SIZE/2 and player.pos.z<b.pos.z+TILE_SIZE) then
        player.dead = true //---------> kill player
        player.killedBy = b.sprite
      end
      
      //Chek if blocks need to be removed (out of screen)
      if( (b.isoY+camera.y < -250 or b.isoY+camera.y > 250) and
          blocks.length>TARGET_BLOCKS_COUNT) then
          blocks.removeElement(b)
      end
    end
    
    //check game over
    if player.speed.z<-50 then
      init() //Restart Game
    end
  end
  //-----------------------------------
   
  //sort blocks by Z before drawing
  blocks.sortList(zsort)
  
  //-----------
  intro.update()
  help.update()
  quests.update()
  gui.update()
  particles.update()
  songs.update()
  //-----------
  fps.update()
  
  time = system.time()-time
  if time>update_time then
    update_time = time
  else
    update_time *= .99
  end
  
  // //-----------------------
  // //DEBUG purpose
  // gui.plotData.insert(update_time)
  // if gui.plotData.length> 200 then gui.plotData.pop() end
  // //-----------------------
  
end

draw = function()
  
  background.draw()
  
  if pauseGame then
    for b in blocksRot
      b.draw()
    end
    else
     for b in blocks
      b.draw()
    end
  end
  
  intro.draw()
  help.draw()
  quests.draw()
  particles.draw()
  gui.draw()
  
  // local h1Iso = head1.pos.toIso()
  // local h2Iso = head2.pos.toIso()
  
  // screen.fillRect(h1Iso[0]+camera.x,h1Iso[1]+camera.y,8,8,"#F0F")
  // screen.fillRect(h2Iso[0]+camera.x,h2Iso[1]+camera.y,8,8,"#FF0")
  
  
end

p3d = class

  constructor = function(x,y,z)
    this.x=x
    this.y=y
    this.z=z
  end
  
  toIso = function()
   local isoX = (x-y)/2 
   local isoY = -(x+y)/4 + (z/2) 
   return [isoX,isoY]
  end
  
  distance = function(other)
    local dx = (x-other.x)
    local dy = (y-other.y)
    local dz = (z-other.z)
    return sqrt(dx*dx+dy*dy+dz*dz)
  end
  
  clone = function()
    local c = object
      x = this.x
      y = this.y
      z = this.z
    end
    return c
  end
  
end

particles = object

  init = function()
    parts = []
  end
  
  addScore = function(_x,_y,_text)
    local p = object
      x = _x
      y = _y
      vx = 0
      vy = 1
      text = _text
      life = 2
      h = 16
      color = "#FFF"
    end
    parts.push(p)
  end
  
  addDust = function(_x,_y)
    local p = object
      x = _x
      y = _y
      z = 1
      vx = -(random.next()/10.0) 
      vy = -(random.next()/10.0)
      life = 2
      h = 8
      w = 8
      sprite = "dust"
    end
    parts.push(p)
    
  end
  
  addQuestItem = function(_x,_y,_sprite)
    local p = object
      x = _x 
      y = _y 
      vx = (random.next()-0.5) * 10
      vy = (-random.next()) * 20
      gotoQuest = true
      sprite = _sprite
      life = 3
      w = TILE_SIZE
      h = TILE_SIZE
      z = 1
    end
    parts.push(p)
  end
  
  update = function()
    for p in parts
      if p.life > 0 then
        p.life -= 0.016
        p.x += p.vx
        p.y += p.vy
        p.vx *= 0.98
        p.vy *= 0.98
        if p.gotoQuest then
          p.x += (0-camera.x-p.x)/10.0
          p.y += (115-camera.y-p.y)/10.0
          p.z += 0.010
          if p.y + camera.y > 110 then
            parts.removeElement(p)
          end
        end
      else
        parts.removeElement(p)
      end
    end
  end
  
  draw = function()
    for p in parts
      local x =  p.x + camera.x
      local y =  p.y + camera.y
      if p.text then
        screen.drawText(p.text,x,y,p.h,p.color)
        screen.setLineWidth = 2
        // screen.drawTextOutline(p.text,x,y,p.h,"#000")
        // screen.setLineWidth = 1
      elsif p.sprite then
        screen.drawSprite(p.sprite,x,y,p.w*p.z)
      end
    end
  end

end

pathhead = class

  constructor = function(dir,active,biome)
    this.dir = dir
    this.active = active
    this.biome = biome
    pos = new p3d()
    steps = 0
    steps_total = 0
    stepsFromChanges = 0
    distanceToPlayer = 0
  end
  
  stepAhead = function()
    if dir > 0 then
      if(levelReverse) then
        pos.x += TILE_SIZE
      else
        pos.x -= TILE_SIZE
      end
    else
      if(levelReverse) then
        pos.y += TILE_SIZE
      else
        pos.y -= TILE_SIZE
      end
    end
  end
  
end

//TODO: MOVE PLAYER CODE HERE

playerblock = class extends block

  constructor = function(name,x,y,z,solid,locked)
    super(name,x,y,z,solid,locked)
    direction = 0
    direction_prev = 0
    reverse = false
    onSolid = false
    onSolidPrev = false
    jumps_count = 0
    dead = false
    locked = false
    msDead = 0
    isoShadowX = 0
    isoShadowY = 0
    jumpHeight = 0
    fallToDeath = false
    killedBy = 0
    onRamp = true
    biomeUnder = 0
  end
  
  update = function()
    
    //calc ball speed from level
    local gameSpeed = 1 + levelSpeed * 0.005
    //sprites[name].fps = 10 + gameSpeed*0.05

    //Move player
    if not dead then
      local user_input = false
      if keyboard.press.LEFT or (mouse.press and touch.x<-30 and touch.y<0) then
         user_input = true
         direction = "sx"
      elsif keyboard.press.RIGHT or (mouse.press and touch.x>30 and touch.y<0) then
        user_input = true
        direction = "dx"
      end
      
      if user_input and quests.arenaUnlocked then
        if direction == direction_prev then
          levelReverse = not levelReverse
          user_input = false
        end
      end
      
      //jump
      if user_input and 
        direction == direction_prev and 
        onSolid then 
          speed.z = 10
          sounds.jump()
          jumps_count += 1
      end
      
      //move
      speed.x = 0
      speed.y = 0
      if levelReverse then 
        if direction == "sx" then speed.y = gameSpeed end
        if direction == "dx" then speed.x = gameSpeed end
      else
        if direction == "sx" then speed.x = -gameSpeed end
        if direction == "dx" then speed.y = -gameSpeed end
      end
      
      //--------------
      direction_prev = direction
      
    else
      msDead+=0.016
      locked = msDead < 1.0
      //-------------------
      if killedBy == "dungeonbox_burning" then
        sprite = "ballfire"
      end
    end
    
    //Stop anim while jumping
    if abs(speed.z) > 1 then sprites["ball"].setFrame(0) end
    
    //apply gravity
    acc.z = -GRAVITY
    //Find solid ground under player
    onSolid = false
    biomeUnder = 0
    for b in blocks
      if(not dead and b!=this)then
        local dz = (pos.z - b.pos.z - TILE_SIZE) 
        local absdx = abs(b.pos.x-pos.x) 
        local absdy = abs(b.pos.y-pos.y) 
        
        if absdx<=TILE_SIZE/2 and absdy<=TILE_SIZE/2 then
          jumpHeight = max(0,player.pos.z - b.pos.z - TILE_SIZE)
          
          if b.solid then
            local pShadow = new p3d(pos.x,pos.y,pos.z)
            if jumpHeight > 0 then 
              pShadow.z = b.pos.z + TILE_SIZE
            end
            local isoShadow = pShadow.toIso()
            isoShadowX = isoShadow[0]
            isoShadowY = isoShadow[1]
            
            onRamp = (b.sprite.indexOf("ramp")>=0)
            
            if onRamp then
              if global.levelReverse then
                pos.z -= 1.2
               else
                pos.z += 1.2
              end
            end
          
            if(dz<1 and b.locked) then
              onSolid = true 
              biomeUnder = b.biome
              if speed.z<5 then //little hack
                acc.z = speed.z = 0 //stop speed of solid
              end
              if dz<-2*TILE_SIZE then //under the tile --> dead
                dead = true
                msDead = 1
              elsif dz<-1 then //under the tile a little, move it up
                if not onRamp then
                  speed.z += 1  //move it out
                end
              end
            end
          end
        end//if solid
      end //if dead
    end
    
    //Trigger stomp sound
    if onSolid and not onSolidPrev and speedZPrev<-5 then
      sounds.stomp()
      fallToDeath = false
    end
    onSolidPrev = onSolid
    speedZPrev = speed.z
    
    //Trigger falling to death sound
    if not onSolid and speed.z<-15 and not fallToDeath then
      fallToDeath = true
      sounds.fall()
    end
    
    // if onSolid and random.next()>0.90 then
    //   particles.addDust(isoX,isoY)
    // end
    
    ////
    super()
  end

  draw = function()
    local shadowSize = TILE_SIZE*(1-(jumpHeight/200))
    screen.setDrawAnchor(0,-1)
    screen.drawSprite("ball_shadow",isoShadowX + camera.x,isoShadowY + camera.y, shadowSize, shadowSize)
    screen.setDrawAnchor(0,0)
    super()
  end

end

quests = object

  init = function()
    showScroll = false
    itemsToCollectForCompleteQuest = 1
    rotAngle = 0
    rotSpeed = 0
    pauseTimer = 0
    animationTimer = 0
    arenaUnlocked = false
    randomizeQuest()
  end
  
  randomizeQuest = function()
    //------
    itemsToCollect = []
    itemsCollected = []
    //extract all items collectable
    local allCollectables = []
    for b in biomes
      for c in b.collectables
        allCollectables.push(c)
      end
    end
    //Add randomly to the list of items to collect
    for i = 0 to itemsToCollectForCompleteQuest
      itemsToCollect.push(tools.randomList(allCollectables))
    end
  end
  
  newItemCollected = function(item,scoreToAdd)
    //Add score
    score += scoreToAdd
    //Score particle
    particles.addScore(item.isoX,item.isoY,"+"+scoreToAdd)
    //Compare if the items is the next to collect
    local index = itemsCollected.length
    if itemsToCollect[index] == item.sprite then
      itemsCollected.push(item.sprite)
      particles.addQuestItem(item.isoX,item.isoY,item.sprite)
    end
    
    //Check if we collect all items
    if itemsCollected.length >= itemsToCollectForCompleteQuest then
      //Slow down player (half it?)
      global.levelSpeed = global.levelSpeed / 3
      //
      global.pauseGame = true
    end
    
  end
  
  update = function()
    if not showScroll then
      randomizeQuest()
    end
    
    if global.pauseGame then
      animationTimer += 0.016
      rotAngle+=rotSpeed
      rotSpeed += rotSpeed*0.001
      if rotAngle >=2*PI then 
        rotSpeed = rotSpeed*-1
      end
      
      //rotAngle = EaseType.easeInOutElastic(animationTimer)*2*PI
      
      if rotAngle <= 0 then
        rotAngle = 0
        rotSpeed = 0
        pauseTimer += 0.016
      end
     
      if pauseTimer > 0.5 then
        global.pauseGame = false
        global.reverseCount = global.reverseCount + 1
        songs.fadeToNextSong(itemsToCollectForCompleteQuest)
        itemsToCollectForCompleteQuest += 1
        randomizeQuest()
        //print("new quest start")
      end
    else
        animationTimer = 0
        pauseTimer = 0
        rotAngle = 0
        rotSpeed = 0.07
    end
    
    
  end
  
  draw = function()
    //--------------
    if showScroll then
      //calc scroll width (items to collect + 2 border)
      local scrollWidth = (itemsToCollectForCompleteQuest+2)*16
      for i = 0 to itemsToCollectForCompleteQuest + 1
        local x = (-scrollWidth/2) + (i*16)
         if i == 0 then 
           screen.drawSprite("questscrollleft",x+5,115, 16)
         elsif i==itemsToCollectForCompleteQuest+1 then
           screen.drawSprite("questscrollright",x+5,115, 16)
         else
          screen.drawSprite("questscrollcenter",x+5,115, 16)
          
          if itemsCollected[i-1] then
            screen.drawSprite(itemsToCollect[i-1],x+5,115,32)
          else
            screen.drawSprite(itemsToCollect[i-1]+"_empty",x+5,115,32)  
          end
         end
      end
    end
    //--------------
    if global.pauseGame then
      screen.drawSprite("questcomplete",0,50, 175)
    end
  end

end

songs = object

 masterVolume = 0.4
 songMain = ""
 songSecondary = ""
 fadeMix = 1
 songNames = ["daizlzeroimpression",
              "rolemusictheblackframe",
              "rolemusicstrawfields"]
  
  update = function()
   if fadeMix < 1 then
    fadeMix += 0.008
    songMain.setVolume((1-fadeMix)*masterVolume)
    songSecondary.setVolume(fadeMix*masterVolume)
   else
    if songSecondary then
      songMain = songSecondary
      songSecondary = 0
    end
   end
  end
  
  fadeToNextSong = function(index)
    index = index % songNames.length
    songSecondary = audio.playMusic(songNames[index],0,true)
    songSecondary.setVolume(0)
    fadeMix = 0
  end

end

sounds = object
  
  notes = ["C","G","D"]

  beepNote = function(note,tone)
    audio.beep("saw volume 50 duration 50 span 80 " +
      notes[note%3]  + tone )
  end
  
  collect = function()
    audio.beep("saw volume 50 duration 100 span 80 C5 G5 volume 40 C6 G6 volume 20 C7 G7")
  end
  
  jump = function()
    audio.playSound("jump")
  end
  
  stomp = function()
    audio.playSound("stomp")
  end
  
  fall = function()
    audio.playSound("fall")
  end
  
 
  
  
  
end


tools = object
  hue2rgb = function (p, q, t)
            if(t < 0) then t += 1 end
            if(t > 1) then t -= 1 end
            if(t < 1/6) then return p + (q - p) * 6 * t end
            if(t < 1/2) then return q end
            if(t < 2/3) then return p + (q - p) * (2/3 - t) * 6 end
            return p
  end
  
  toRGB = function(h,s,l) //[0, 1]
    r = g = b = 0
    if(s == 0) then
        r = g = b = l // achromatic
    else
        q = 0
        if l < 0.5 then q =  l * (1 + s) else q =  l + s - l * s end
        p = 2 * l - q
        r = hue2rgb(p, q, h + 1/3)
        g = hue2rgb(p, q, h)
        b = hue2rgb(p, q, h - 1/3)
    end
  
    return "rgb("+round(r * 255)+","+ round(g * 255)+","+round(b * 255)+")"
  end
  
  toHSL = function(r,g,b)//[0, 255]
    local r1 = r/255
    local g1 = g/255
    local b1 = b/255
    local cmax = max(max(r1,g1),b1)
    local cmin = min(min(r1,g1),b1)
    local delta = cmax-cmin
    
    //HUE
    local h = 0
    local s = 0
    local l = (cmax+cmin) / 2 
    
    if delta !=0 then
      if l<0.5 then
          s = delta / (cmax + cmin)
      else
          s = delta / (2.0 - cmax - cmin)
      end
      
      deltaR = ((cmax - r1) / 6.0 + (delta / 2.0)) / delta
      deltaG = ((cmax - g1) / 6.0 + (delta / 2.0)) / delta
      deltaB = ((cmax - b1) / 6.0 + (delta / 2.0)) / delta
      
      if r1 == cmax then
            h = deltaB - deltaG
        elsif (g1 == cmax) then
            h = (1.0 / 3.0) + deltaR - deltaB
        elsif (b1 == cmax) then
            h = (2.0 / 3.0) + deltaG - deltaR
        end
    
      if h < 0 then h += 1.0 end
      if h > 1 then h -= 1.0 end 
    end
    
    return [h,s,l]
  end
  
  colorToValues = function(sRGB)
    //"rgb(15,0,150)"
    local first = sRGB.indexOf("(")
    local last = sRGB.indexOf(")")
    local sub = sRGB.substring(first+1,last)
    local splits = sub.split(",")
    local r = round(splits[0])
    local g = round(splits[1])
    local b = round(splits[2])
    return [r,g,b]
  end
    
  randomList = function(list)
    local item = random.nextInt(list.length)
    return list[item]
  end
  
  rot3d = function(point,center,ax,ay,az)
  	local a = point.x-center.x
  	local b = point.y-center.y
  	local c = point.z-center.z
  	
  	local a1 = a*cos(az)-b*sin(az) 
    local b1 = a*sin(az)+b*cos(az)
  	local c1 = c
  
  	local c2 = c1*cos(ay)-a1*sin(ay) 	
  	local a2 = c1*sin(ay)+a1*cos(ay)
    local b2 = b1
  	
  	local b3 = b2*cos(ax)-c2*sin(ax) 	
  	local c3 = b2*sin(ax)+c2*cos(ax)
    local a3 = a2		
  	
  	local pointRot = object
    	x=center.x+a3
    	y=center.y+b3
    	z=center.z+c3
  	end		
  	return pointRot
  end
end



</script></html>